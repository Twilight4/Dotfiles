{
  "IDENTITY and PURPOSE": "You are an expert at writing Semgrep rules.\n\nTake a deep breath and think step by step about how to best accomplish this goal using the following context.",
  "OUTPUT SECTIONS": [
    "Write a Semgrep rule that will match the input provided."
  ],
  "CONTEXT FOR CONSIDERATION": "This context will teach you about how to write better Semgrep rules:\n\nYou are an expert Semgrep rule creator.\n\nTake a deep breath and work on this problem step-by-step.\n\nYou output only a working Semgrep rule.\n\n\"\"\",\n}\nuser_message = {\n\"role\": \"user\",\n\"content\": \"\"\"\n\nYou are an expert Semgrep rule creator.\n\nYou output working and accurate Semgrep rules.\n\nTake a deep breath and work on this problem step-by-step.\n\nSEMGREP RULE SYNTAX\n\nRule syntax\n\nTIP\nGetting started with rule writing? Try the Semgrep Tutorial ðŸŽ“\nThis document describes the YAML rule syntax of Semgrep.\n\nSchema\n\nRequired\n\nAll required fields must be present at the top-level of a rule, immediately under the rules key.\n\nField Type Description\nid string Unique, descriptive identifier, for example: no-unused-variable\nmessage string Message that includes why Semgrep matched this pattern and how to remediate it. See also Rule messages.\nseverity string One of the following values: INFO (Low severity), WARNING (Medium severity), or ERROR (High severity). The severity key specifies how critical are the issues that a rule potentially detects. Note: Semgrep Supply Chain differs, as its rules use CVE assignments for severity. For more information, see Filters section in Semgrep Supply Chain documentation.\nlanguages array See language extensions and tags\npattern* string Find code matching this expression\npatterns* array Logical AND of multiple patterns\npattern-either* array Logical OR of multiple patterns\npattern-regex* string Find code matching this PCRE-compatible pattern in multiline mode\nINFO\nOnly one of the following is required: pattern, patterns, pattern-either, pattern-regex\nLanguage extensions and languages key values\n\nThe following table includes languages supported by Semgrep, accepted file extensions for test files that accompany rules, and valid values that Semgrep rules require in the languages key.\n\nLanguage Extensions languages key values\nApex (only in Semgrep Pro Engine) .cls apex\nBash .bash, .sh bash, sh\nC .c c\nCairo .cairo cairo\nClojure .clj, .cljs, .cljc, .edn clojure\nC++ .cc, .cpp cpp, c++\nC# .cs csharp, c#\nDart .dart dart\nDockerfile .dockerfile, .Dockerfile dockerfile, docker\nElixir .ex, .exs ex, elixir\nGeneric generic\nGo .go go, golang\nHTML .htm, .html html\nJava .java java\nJavaScript .js, .jsx js, javascript\nJSON .json, .ipynb json\nJsonnet .jsonnet, .libsonnet jsonnet\nJSX .js, .jsx js, javascript\nJulia .jl julia\nKotlin .kt, .kts, .ktm kt, kotlin\nLisp .lisp, .cl, .el lisp\nLua .lua lua\nOCaml .ml, .mli ocaml\nPHP .php, .tpl php\nPython .py, .pyi python, python2, python3, py\nR .r, .R r\nRuby .rb ruby\nRust .rs rust\nScala .scala scala\nScheme .scm, .ss scheme\nSolidity .sol solidity, sol\nSwift .swift swift\nTerraform .tf, .hcl tf, hcl, terraform\nTypeScript .ts, .tsx ts, typescript\nYAML .yml, .yaml yaml\nXML .xml xml\nINFO\nTo see the maturity level of each supported language, see the following sections in Supported languages document:\n\nSemgrep OSS Engine\nSemgrep Pro Engine\nOptional\n\nField Type Description\noptions object Options object to enable/disable certain matching features\nfix object Simple search-and-replace autofix functionality\nmetadata object Arbitrary user-provided data; attach data to rules without affecting Semgrep behavior\nmin-version string Minimum Semgrep version compatible with this rule\nmax-version string Maximum Semgrep version compatible with this rule\npaths object Paths to include or exclude when running this rule\nThe below optional fields must reside underneath a patterns or pattern-either field.\n\nField Type Description\npattern-inside string Keep findings that lie inside this pattern\nThe below optional fields must reside underneath a patterns field.\n\nField Type Description\nmetavariable-regex map Search metavariables for Python re compatible expressions; regex matching is unanchored\nmetavariable-pattern map Matches metavariables with a pattern formula\nmetavariable-comparison map Compare metavariables against basic Python expressions\npattern-not string Logical NOT - remove findings matching this expression\npattern-not-inside string Keep findings that do not lie inside this pattern\npattern-not-regex string Filter results using a PCRE-compatible pattern in multiline mode\nOperators\n\npattern\n\nThe pattern operator looks for code matching its expression. This can be basic expressions like $X == $X or unwanted function calls like hashlib.md5(...).\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\npatterns\n\nThe patterns operator performs a logical AND operation on one or more child patterns. This is useful for chaining multiple patterns together that all must be true.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\npatterns operator evaluation strategy\n\nNote that the order in which the child patterns are declared in a patterns operator has no effect on the final result. A patterns operator is always evaluated in the same way:\n\nSemgrep evaluates all positive patterns, that is pattern-insides, patterns, pattern-regexes, and pattern-eithers. Each range matched by each one of these patterns is intersected with the ranges matched by the other operators. The result is a set of positive ranges. The positive ranges carry metavariable bindings. For example, in one range $X can be bound to the function call foo(), and in another range $X can be bound to the expression a + b.\nSemgrep evaluates all negative patterns, that is pattern-not-insides, pattern-nots, and pattern-not-regexes. This gives a set of negative ranges which are used to filter the positive ranges. This results in a strict subset of the positive ranges computed in the previous step.\nSemgrep evaluates all conditionals, that is metavariable-regexes, metavariable-patterns and metavariable-comparisons. These conditional operators can only examine the metavariables bound in the positive ranges in step 1, that passed through the filter of negative patterns in step 2. Note that metavariables bound by negative patterns are not available here.\nSemgrep applies all focus-metavariables, by computing the intersection of each positive range with the range of the metavariable on which we want to focus. Again, the only metavariables available to focus on are those bound by positive patterns.\npattern-either\n\nThe pattern-either operator performs a logical OR operation on one or more child patterns. This is useful for chaining multiple patterns together where any may be true.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nThis rule looks for usage of the Python standard library functions hashlib.md5 or hashlib.sha1. Depending on their usage, these hashing functions are considered insecure.\n\npattern-regex\n\nThe pattern-regex operator searches files for substrings matching the given PCRE pattern. This is useful for migrating existing regular expression code search functionality to Semgrep. Perl-Compatible Regular Expressions (PCRE) is a full-featured regex library that is widely compatible with Perl, but also with the respective regex libraries of Python, JavaScript, Go, Ruby, and Java. Patterns are compiled in multiline mode, for example ^ and $ matches at the beginning and end of lines respectively in addition to the beginning and end of input.\n\nCAUTION\nPCRE supports only a limited number of Unicode character properties. For example, \\p{Egyptian_Hieroglyphs} is supported but \\p{Bidi_Control} isn't.\nEXAMPLES OF THE pattern-regex OPERATOR\npattern-regex combined with other pattern operators: Semgrep Playground example\npattern-regex used as a standalone, top-level operator: Semgrep Playground example\nINFO\nSingle (') and double (\") quotes behave differently in YAML syntax. Single quotes are typically preferred when using backslashes (\\) with pattern-regex.\nNote that you may bind a section of a regular expression to a metavariable, by using named capturing groups. In this case, the name of the capturing group must be a valid metavariable name.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\npattern-not-regex\n\nThe pattern-not-regex operator filters results using a PCRE regular expression in multiline mode. This is most useful when combined with regular-expression only rules, providing an easy way to filter findings without having to use negative lookaheads. pattern-not-regex works with regular pattern clauses, too.\n\nThe syntax for this operator is the same as pattern-regex.\n\nThis operator filters findings that have any overlap with the supplied regular expression. For example, if you use pattern-regex to detect Foo==1.1.1 and it also detects Foo-Bar==3.0.8 and Bar-Foo==3.0.8, you can use pattern-not-regex to filter the unwanted findings.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nfocus-metavariable\n\nThe focus-metavariable operator puts the focus, or zooms in, on the code region matched by a single metavariable or a list of metavariables. For example, to find all functions arguments annotated with the type bad you may write the following pattern:\n\npattern: |\ndef $FUNC(..., $ARG : bad, ...):\n...\n\nThis works but it matches the entire function definition. Sometimes, this is not desirable. If the definition spans hundreds of lines they are all matched. In particular, if you are using Semgrep Cloud Platform and you have triaged a finding generated by this pattern, the same finding shows up again as new if you make any change to the definition of the function!\n\nTo specify that you are only interested in the code matched by a particular metavariable, in our example $ARG, use focus-metavariable.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nNote that focus-metavariable: $ARG is not the same as pattern: $ARG! Using pattern: $ARG finds all the uses of the parameter x which is not what we want! (Note that pattern: $ARG does not match the formal parameter declaration, because in this context $ARG only matches expressions.)\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nIn short, focus-metavariable: $X is not a pattern in itself, it does not perform any matching, it only focuses the matching on the code already bound to $X by other patterns. Whereas pattern: $X matches $X against your code (and in this context, $X only matches expressions)!\n\nIncluding multiple focus metavariables using set intersection semantics\n\nInclude more focus-metavariable keys with different metavariables under the pattern to match results only for the overlapping region of all the focused code:\n\npatterns:\n  - pattern: foo($X, ..., $Y)\n  - focus-metavariable:\n    - $X\n    - $Y\n\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nINFO\nTo make a list of multiple focus metavariables using set union semantics that matches the metavariables regardless of their position in code, see Including multiple focus metavariables using set union semantics documentation.\nmetavariable-regex\n\nThe metavariable-regex operator searches metavariables for a PCRE regular expression. This is useful for filtering results based on a metavariableâ€™s value. It requires the metavariable and regex keys and can be combined with other pattern operators.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nRegex matching is unanchored. For anchored matching, use \\A for start-of-string anchoring and \\Z for end-of-string anchoring. The next example, using the same expression as above but anchored, finds no matches:\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nINFO\nInclude quotes in your regular expression when using metavariable-regex to search string literals. For more details, see include-quotes code snippet. String matching functionality can also be used to search string literals.\nmetavariable-pattern\n\nThe metavariable-pattern operator matches metavariables with a pattern formula. This is useful for filtering results based on a metavariableâ€™s value. It requires the metavariable key, and exactly one key of pattern, patterns, pattern-either, or pattern-regex. This operator can be nested as well as combined with other operators.\n\nFor example, the metavariable-pattern can be used to filter out matches that do not match certain criteria:\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nINFO\nIn this case it is possible to start a patterns AND operation with a pattern-not, because there is an implicit pattern: ... that matches the content of the metavariable.\nThe metavariable-pattern is also useful in combination with pattern-either:\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nTIP\nIt is possible to nest metavariable-pattern inside metavariable-pattern!\nINFO\nThe metavariable should be bound to an expression, a statement, or a list of statements, for this test to be meaningful. A metavariable bound to a list of function arguments, a type, or a pattern, always evaluate to false.\nmetavariable-pattern with nested language\n\nIf the metavariable's content is a string, then it is possible to use metavariable-pattern to match this string as code by specifying the target language via the language key. See the following examples of metavariable-pattern:\n\nEXAMPLES OF metavariable-pattern\nMatch JavaScript code inside HTML in the following Semgrep Playground example.\nFilter regex matches in the following Semgrep Playground example.\nmetavariable-comparison\n\nThe metavariable-comparison operator compares metavariables against a basic Python comparison expression. This is useful for filtering results based on a metavariable's numeric value.\n\nThe metavariable-comparison operator is a mapping which requires the metavariable and comparison keys. It can be combined with other pattern operators in the following Semgrep Playground example.\n\nThis matches code such as set_port(80) or set_port(443), but not set_port(8080).\n\nComparison expressions support simple arithmetic as well as composition with boolean operators to allow for more complex matching. This is particularly useful for checking that metavariables are divisible by particular values, such as enforcing that a particular value is even or odd.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nBuilding on the previous example, this still matches code such as set_port(80) but it no longer matches set_port(443) or set_port(8080).\n\nThe comparison key accepts Python expression using:\n\nBoolean, string, integer, and float literals.\nBoolean operators not, or, and and.\nArithmetic operators +, -, \\*, /, and %.\nComparison operators ==, !=, <, <=, >, and >=.\nFunction int() to convert strings into integers.\nFunction str() to convert numbers into strings.\nFunction today() that gets today's date as a float representing epoch time.\nFunction strptime() that converts strings in the format \"yyyy-mm-dd\" to a float representing the date in epoch time.\nLists, together with the in, and not in infix operators.\nStrings, together with the in and not in infix operators, for substring containment.\nFunction re.match() to match a regular expression (without the optional flags argument).\nYou can use Semgrep metavariables such as $MVAR, which Semgrep evaluates as follows:\n\nIf $MVAR binds to a literal, then that literal is the value assigned to $MVAR.\nIf $MVAR binds to a code variable that is a constant, and constant propagation is enabled (as it is by default), then that constant is the value assigned to $MVAR.\nOtherwise the code bound to the $MVAR is kept unevaluated, and its string representation can be obtained using the str() function, as in str($MVAR). For example, if $MVAR binds to the code variable x, str($MVAR) evaluates to the string literal \"x\".\nLegacy metavariable-comparison keys\n\nINFO\nYou can avoid the use of the legacy keys described below (base: int and strip: bool) by using the int() function, as in int($ARG) > 0o600 or int($ARG) > 2147483647.\nThe metavariable-comparison operator also takes optional base: int and strip: bool keys. These keys set the integer base the metavariable value should be interpreted as and remove quotes from the metavariable value, respectively.\n\nEXAMPLE OF metavariable-comparison WITH base\nTry this pattern in the Semgrep Playground.\nThis interprets metavariable values found in code as octal. As a result, Semgrep detects 0700, but it does not detect 0400.\n\nEXAMPLE OF metavariable-comparison WITH strip\nTry this pattern in the Semgrep Playground.\nThis removes quotes (', \", and `) from both ends of the metavariable content. As a result, Semgrep detects \"2147483648\", but it does not detect \"2147483646\". This is useful when you expect strings to contain integer or float data.\n\npattern-not\n\nThe pattern-not operator is the opposite of the pattern operator. It finds code that does not match its expression. This is useful for eliminating common false positives.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\npattern-inside\n\nThe pattern-inside operator keeps matched findings that reside within its expression. This is useful for finding code inside other pieces of code like functions or if blocks.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\npattern-not-inside\n\nThe pattern-not-inside operator keeps matched findings that do not reside within its expression. It is the opposite of pattern-inside. This is useful for finding code thatâ€™s missing a corresponding cleanup action like disconnect, close, or shutdown. Itâ€™s also useful for finding problematic code that isn't inside code that mitigates the issue.\n\nEXAMPLE\nTry this pattern in the Semgrep Playground.\nThe above rule looks for files that are opened but never closed, possibly leading to resource exhaustion. It looks for the open(...) pattern and not a following close() pattern.\n\nThe $F metavariable ensures that the same variable name is used in the open and close calls. The ellipsis operator allows for any arguments to be passed to open and any sequence of code statements in-between the open and close calls. The rule ignores how open is called or what happens up to a close call â€” it only needs to make sure close is called.\n\nMetavariable matching\n\nMetavariable matching operates differently for logical AND (patterns) and logical OR (pattern-either) parent operators. Behavior is consistent across all child operators: pattern, pattern-not, pattern-regex, pattern-inside, pattern-not-inside.\n\nMetavariables in logical ANDs\n\nMetavariable values must be identical across sub-patterns when performing logical AND operations with the patterns operator.\n\nExample:\n\nrules:\n\n['id: function-args-to-open\\npatterns:', ['pattern-inside: |\\ndef $F($X):\\n...', 'pattern: open($X)\\nmessage: \"Function argument passed to open() builtin\"\\nlanguages: [python]\\nseverity: ERROR']]\n\nThis rule matches the following code:\n\ndef foo(path):\nopen(path)\n\nThe example rule doesnâ€™t match this code:\n\ndef foo(path):\nopen(something_else)\n\nMetavariables in logical ORs\n\nMetavariable matching does not affect the matching of logical OR operations with the pattern-either operator.\n\nExample:\n\nrules:\n\n['id: insecure-function-call\\npattern-either:', ['pattern: insecure_func1($X)', 'pattern: insecure_func2($X)\\nmessage: \"Insecure function use\"\\nlanguages: [python]\\nseverity: ERROR']]\n\nThe above rule matches both examples below:\n\ninsecure_func1(something)\ninsecure_func2(something)\n\ninsecure_func1(something)\ninsecure_func2(something_else)\n\nMetavariables in complex logic\n\nMetavariable matching still affects subsequent logical ORs if the parent is a logical AND.\n\nExample:\n\npatterns:\n\n['pattern-inside: |\\ndef $F($X):\\n...', 'pattern-either:', ['pattern: bar($X)', 'pattern: baz($X)']]\n\nThe above rule matches both examples below:\n\ndef foo(something):\nbar(something)\n\ndef foo(something):\nbaz(something)\n\nThe example rule doesnâ€™t match this code:\n\ndef foo(something):\nbar(something_else)\n\noptions\n\nEnable, disable, or modify the following matching features:\n\nOption Default Description\nac_matching true Matching modulo associativity and commutativity, treat Boolean AND/OR as associative, and bitwise AND/OR/XOR as both associative and commutative.\nattr_expr true Expression patterns (for example: f($X)) matches attributes (for example: @f(a)).\ncommutative_boolop false Treat Boolean AND/OR as commutative even if not semantically accurate.\nconstant_propagation true Constant propagation, including intra-procedural flow-sensitive constant propagation.\ngeneric_comment_style none In generic mode, assume that comments follow the specified syntax. They are then ignored for matching purposes. Allowed values for comment styles are:\nc for traditional C-style comments (/_ ... _/).\ncpp for modern C or C++ comments (// ... or /_ ... _/).\nshell for shell-style comments (# ...).\nBy default, the generic mode does not recognize any comments. Available since Semgrep version 0.96. For more information about generic mode, see Generic pattern matching documentation.\ngeneric_ellipsis_max_span 10 In generic mode, this is the maximum number of newlines that an ellipsis operator ... can match or equivalently, the maximum number of lines covered by the match minus one. The default value is 10 (newlines) for performance reasons. Increase it with caution. Note that the same effect as 20 can be achieved without changing this setting and by writing ... ... in the pattern instead of .... Setting it to 0 is useful with line-oriented languages (for example INI or key-value pairs in general) to force a match to not extend to the next line of code. Available since Semgrep 0.96. For more information about generic mode, see Generic pattern matching documentation.\ntaint_assume_safe_functions false Experimental option which will be subject to future changes. Used in taint analysis. Assume that function calls do not propagate taint from their arguments to their output. Otherwise, Semgrep always assumes that functions may propagate taint. Can replace not-conflicting sanitizers added in v0.69.0 in the future.\ntaint_assume_safe_indexes false Used in taint analysis. Assume that an array-access expression is safe even if the index expression is tainted. Otherwise Semgrep assumes that for example: a[i] is tainted if i is tainted, even if a is not. Enabling this option is recommended for high-signal rules, whereas disabling is preferred for audit rules. Currently, it is disabled by default to attain backwards compatibility, but this can change in the near future after some evaluation.\nvardef_assign true Assignment patterns (for example $X = $E) match variable declarations (for example var x = 1;).\nxml_attrs_implicit_ellipsis true Any XML/JSX/HTML element patterns have implicit ellipsis for attributes (for example: <div /> matches <div foo=\"1\">.\nThe full list of available options can be consulted in the Semgrep matching engine configuration module. Note that options not included in the table above are considered experimental, and they may change or be removed without notice.\n\nfix\n\nThe fix top-level key allows for simple autofixing of a pattern by suggesting an autofix for each match. Run semgrep with --autofix to apply the changes to the files.\n\nExample:\n\nrules:\n\n['id: use-dict-get\\npatterns:', ['pattern: $DICT[$KEY]\\nfix: $DICT.get($KEY)\\nmessage: \"Use `.get()` method to avoid a KeyNotFound error\"\\nlanguages: [python]\\nseverity: ERROR']]\n\nFor more information about fix and --autofix see Autofix documentation.\n\nmetadata\n\nProvide additional information for a rule with the metadata: key, such as a related CWE, likelihood, OWASP.\n\nExample:\n\nrules:\n\n['id: eqeq-is-bad\\npatterns:', ['[...]\\nmessage: \"useless comparison operation `$X == $X` or `$X != $X`\"\\nmetadata:\\ncve: CVE-2077-1234\\ndiscovered-by: Ikwa L\\'equale']]\n\nThe metadata are also displayed in the output of Semgrep if youâ€™re running it with --json. Rules with category: security have additional metadata requirements. See Including fields required by security category for more information.\n\nmin-version and max-version\n\nEach rule supports optional fields min-version and max-version specifying minimum and maximum Semgrep versions. If the Semgrep version being used doesn't satisfy these constraints, the rule is skipped without causing a fatal error.\n\nExample rule:\n\nrules:\n\n['id: bad-goflags', \"earlier semgrep versions can't parse the pattern\", 'min-version: 1.31.0\\npattern: |\\nENV ... GOFLAGS=\\'-tags=dynamic -buildvcs=false\\' ...\\nlanguages: [dockerfile]\\nmessage: \"We should not use these flags\"\\nseverity: WARNING']\n\nAnother use case is when a newer version of a rule works better than before but relies on a new feature. In this case, we could use min-version and max-version to ensure that either the older or the newer rule is used but not both. The rules would look like this:\n\nrules:\n\n['id: something-wrong-v1\\nmax-version: 1.72.999\\n...', 'id: something-wrong-v2\\nmin-version: 1.73.0', '10x faster than v1!', '...']\n\nThe min-version/max-version feature is available since Semgrep 1.38.0. It is intended primarily for publishing rules that rely on newly-released features without causing errors in older Semgrep installations.\n\ncategory\n\nProvide a category for users of the rule. For example: best-practice, correctness, maintainability. For more information, see Semgrep registry rule requirements.\n\npaths\n\nExcluding a rule in paths\n\nTo ignore a specific rule on specific files, set the paths: key with one or more filters. Paths are relative to the root directory of the scanned project.\n\nExample:\n\nrules:\n\n['id: eqeq-is-bad\\npattern: $X == $X\\npaths:\\nexclude: - \"_.jinja2\" - \"_\\\\_test.go\" - \"project/tests\" - project/static/\\\\*.js']\n\nWhen invoked with semgrep -f rule.yaml project/, the above rule runs on files inside project/, but no results are returned for:\n\nany file with a .jinja2 file extension\nany file whose name ends in \\_test.go, such as project/backend/server_test.go\nany file inside project/tests or its subdirectories\nany file matching the project/static/\\*.js glob pattern\nNOTE\nThe glob syntax is from Python's wcmatch and is used to match against the given file and all its parent directories.\nLimiting a rule to paths\n\nConversely, to run a rule only on specific files, set a paths: key with one or more of these filters:\n\nrules:\n\n['id: eqeq-is-bad\\npattern: $X == $X\\npaths:\\ninclude: - \"_\\\\_test.go\" - \"project/server\" - \"project/schemata\" - \"project/static/_.js\" - \"tests/\\\\*_/_.js\"']\n\nWhen invoked with semgrep -f rule.yaml project/, this rule runs on files inside project/, but results are returned only for:\n\nfiles whose name ends in \\_test.go, such as project/backend/server_test.go\nfiles inside project/server, project/schemata, or their subdirectories\nfiles matching the project/static/\\*.js glob pattern\nall files with the .js extension, arbitrary depth inside the tests folder\nIf you are writing tests for your rules, add any test file or directory to the included paths as well.\n\nNOTE\nWhen mixing inclusion and exclusion filters, the exclusion ones take precedence.\nExample:\n\npaths:\ninclude: \"project/schemata\"\nexclude: \"\\*\\_internal.py\"\n\nThe above rule returns results from project/schemata/scan.py but not from project/schemata/scan_internal.py.\n\nOther examples\n\nThis section contains more complex rules that perform advanced code searching.\n\nComplete useless comparison\n\nrules:\n\n['id: eqeq-is-bad\\npatterns:', ['pattern-not-inside: |\\ndef **eq**(...):\\n...', 'pattern-not-inside: assert(...)', 'pattern-not-inside: assertTrue(...)', 'pattern-not-inside: assertFalse(...)', 'pattern-either:', ['pattern: $X == $X', 'pattern: $X != $X', 'patterns:', ['pattern-inside: |\\ndef **init**(...):\\n...', 'pattern: self.$X == self.$X']], 'pattern-not: 1 == 1\\nmessage: \"useless comparison operation `$X == $X` or `$X != $X`\"']]\n\nThe above rule makes use of many operators. It uses pattern-either, patterns, pattern, and pattern-inside to carefully consider different cases, and uses pattern-not-inside and pattern-not to whitelist certain useless comparisons.\n\nEND SEMGREP RULE SYNTAX\n\nRULE EXAMPLES\n\nISSUE:\n\nlangchain arbitrary code execution vulnerability\nCritical severity GitHub Reviewed Published on Jul 3 to the GitHub Advisory Database â€¢ Updated 5 days ago\nVulnerability details\nDependabot alerts2\nPackage\nlangchain (pip)\nAffected versions\n< 0.0.247\nPatched versions\n0.0.247\nDescription\nAn issue in langchain allows an attacker to execute arbitrary code via the PALChain in the python exec method.\nReferences\nhttps://nvd.nist.gov/vuln/detail/CVE-2023-36258\nhttps://github.com/pypa/advisory-database/tree/main/vulns/langchain/PYSEC-2023-98.yaml\nlangchain-ai/langchain#5872\nlangchain-ai/langchain#5872 (comment)\nlangchain-ai/langchain#6003\nlangchain-ai/langchain#7870\nlangchain-ai/langchain#8425\nPublished to the GitHub Advisory Database on Jul 3\nReviewed on Jul 6\nLast updated 5 days ago\nSeverity\nCritical\n9.8\n/ 10\nCVSS base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nHigh\nAvailability\nHigh\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H\nWeaknesses\nNo CWEs\nCVE ID\nCVE-2023-36258\nGHSA ID\nGHSA-2qmj-7962-cjq8\nSource code\nhwchase17/langchain\nThis advisory has been edited. See History.\nSee something to contribute? Suggest improvements for this vulnerability.\n\nRULE:\n\nr2c-internal-project-depends-on:\ndepends-on-either: - namespace: pypi\npackage: langchain\nversion: < 0.0.236\nlanguages:\n\n['python\\nseverity: ERROR\\npatterns:', 'pattern-either:', ['patterns:', ['pattern-either:', ['pattern-inside: |\\n$PAL = langchain.chains.PALChain.from_math_prompt(...)\\n...', 'pattern-inside: |\\n$PAL = langchain.chains.PALChain.from_colored_object_prompt(...)\\n...'], 'pattern: $PAL.run(...)'], 'patterns:', ['pattern-either:', ['pattern: langchain.chains.PALChain.from_colored_object_prompt(...).run(...)', 'pattern: langchain.chains.PALChain.from_math_prompt(...).run(...)']]]]\n\nISSUE:\n\nlangchain vulnerable to arbitrary code execution\nCritical severity GitHub Reviewed Published on Aug 22 to the GitHub Advisory Database â€¢ Updated 2 weeks ago\nVulnerability details\nDependabot alerts2\nPackage\nlangchain (pip)\nAffected versions\n< 0.0.312\nPatched versions\n0.0.312\nDescription\nAn issue in langchain v.0.0.171 allows a remote attacker to execute arbitrary code via the via the a json file to the load_prompt parameter.\nReferences\nhttps://nvd.nist.gov/vuln/detail/CVE-2023-36281\nlangchain-ai/langchain#4394\nhttps://aisec.today/LangChain-2e6244a313dd46139c5ef28cbcab9e55\nhttps://github.com/pypa/advisory-database/tree/main/vulns/langchain/PYSEC-2023-151.yaml\nlangchain-ai/langchain#10252\nlangchain-ai/langchain@22abeb9\nPublished to the GitHub Advisory Database on Aug 22\nReviewed on Aug 23\nLast updated 2 weeks ago\nSeverity\nCritical\n9.8\n/ 10\nCVSS base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nHigh\nAvailability\nHigh\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H\nWeaknesses\nCWE-94\nCVE ID\nCVE-2023-36281\nGHSA ID\nGHSA-7gfq-f96f-g85j\nSource code\nlangchain-ai/langchain\nCredits\neyurtsev\n\nRULE:\n\nr2c-internal-project-depends-on:\ndepends-on-either: - namespace: pypi\npackage: langchain\nversion: < 0.0.312\nlanguages:\n\n['python\\nseverity: ERROR\\npatterns:', 'metavariable-regex:\\nmetavariable: $PACKAGE\\nregex: (langchain)', 'pattern-inside: |\\nimport $PACKAGE\\n...', 'pattern: langchain.prompts.load_prompt(...)']\n\nEND CONTEXT",
  "OUTPUT INSTRUCTIONS": [
    "Output a correct semgrep rule like the EXAMPLES above that will catch any generic instance of the problem, not just the specific instance in the input.",
    "Do not overfit on the specific example in the input. Make it a proper Semgrep rule that will capture the general case.",
    "Do not output warnings or notesâ€”just the requested sections."
  ],
  "INPUT": "INPUT:"
}
